<!doctype html>
<html lang="pt-BR">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>TOTP Local (sem libs)</title>
<style>
  :root { font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial; }
  body { max-width: 680px; margin: 40px auto; padding: 0 16px; }
  h1 { font-size: 1.2rem; margin-bottom: 0.5rem; }
  .row { display: grid; grid-template-columns: 140px 1fr; gap: 8px; align-items: center; margin: 8px 0; }
  input, select { padding: 8px; font-size: 1rem; width: 100%; }
  .code { font-variant-numeric: tabular-nums; font-size: 2.4rem; letter-spacing: 2px; text-align: center; margin: 16px 0; }
  .muted { color: #666; font-size: 0.9rem; }
  .actions { display:flex; gap:8px; justify-content:center; }
  button { padding:8px 12px; font-size:1rem; cursor:pointer; }
  .warn { background:#fff3cd; border:1px solid #ffe69c; padding:8px; margin:8px 0; }
</style>
</head>
<body>
  <h1>TOTP Local (RFC 6238)</h1>

  <div class="row">
    <label for="secret">Segredo (Base32)</label>
    <input id="secret" placeholder="Ex: JBSWY3DPEHPK3PXP" autocomplete="off" value="SEIZZJESKQKLJ7R2"/>
  </div>

  <div class="row">
    <label for="algo">Algoritmo</label>
    <select id="algo">
      <option>SHA-1</option>
      <option>SHA-256</option>
      <option>SHA-512</option>
    </select>
  </div>

  <div class="row">
    <label for="digits">Dígitos</label>
    <select id="digits">
      <option>6</option>
      <option>7</option>
      <option>8</option>
    </select>
  </div>

  <div class="row">
    <label for="period">Período (s)</label>
    <input id="period" type="number" min="15" step="1" value="30" />
  </div>

  <div class="warn muted">
    Use o horário do sistema. Skew de relógio afeta o código. Padrões: 6 dígitos, 30s, SHA-1.
  </div>

  <div class="code" id="code">------</div>
  <div class="muted" style="text-align:center">Expira em <span id="remaining">--</span>s &middot; contador <span id="counter">--</span></div>

  <div class="actions">
    <button id="copyBtn">Copiar código</button>
    <button id="oneBackBtn">Código anterior</button>
    <button id="oneAheadBtn">Próximo código</button>
  </div>

<script>
/* ===== Base32 (RFC 4648) ===== */
function base32ToBytes(b32) {
  const alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567";
  const clean = (b32 || "")
    .toUpperCase()
    .replace(/=+$/g, "")
    .replace(/[\s-]/g, "");
  if (!clean) return new Uint8Array([]);
  let bits = 0, value = 0, index = 0;
  const out = [];
  for (let i = 0; i < clean.length; i++) {
    const idx = alphabet.indexOf(clean[i]);
    if (idx === -1) throw new Error("Base32 inválido em: '" + clean[i] + "'");
    value = (value << 5) | idx;
    bits += 5;
    if (bits >= 8) {
      out.push((value >>> (bits - 8)) & 0xff);
      bits -= 8;
    }
  }
  return new Uint8Array(out);
}

/* ===== HMAC via Web Crypto ===== */
async function hmac(signKeyBytes, msgBytes, hashName) {
  const key = await crypto.subtle.importKey(
    "raw",
    signKeyBytes,
    { name: "HMAC", hash: { name: hashName } },
    false,
    ["sign"]
  );
  const sig = await crypto.subtle.sign("HMAC", key, msgBytes);
  return new Uint8Array(sig);
}

/* ===== HOTP truncation ===== */
function dynamicTruncate(hmacBytes) {
  const offset = hmacBytes[hmacBytes.length - 1] & 0x0f;
  if (offset + 4 > hmacBytes.length) throw new Error("Truncation offset fora do range");
  const p = ((hmacBytes[offset] & 0x7f) << 24) |
            ((hmacBytes[offset + 1] & 0xff) << 16) |
            ((hmacBytes[offset + 2] & 0xff) << 8) |
            (hmacBytes[offset + 3] & 0xff);
  return p >>> 0; // força unsigned
}

/* ===== TOTP ===== */
async function totp({ secretB32, period = 30, digits = 6, algo = "SHA-1", counterOverride = null }) {
  const key = base32ToBytes(secretB32);
  if (!key.length) throw new Error("Informe o segredo em Base32.");
  const now = Math.floor(Date.now() / 1000);
  const counter = counterOverride != null ? counterOverride : Math.floor(now / period);
  const buf = new ArrayBuffer(8);
  const view = new DataView(buf);
  // contador em big-endian
  view.setUint32(0, Math.floor(counter / 0x100000000));
  view.setUint32(4, counter >>> 0);
  const mac = await hmac(key, new Uint8Array(buf), algo);
  const p = dynamicTruncate(mac);
  const mod = 10 ** digits;
  const code = (p % mod).toString().padStart(digits, "0");
  const remaining = period - (now % period);
  return { code, counter, remaining };
}

/* ===== UI wiring ===== */
const el = {
  secret: document.getElementById("secret"),
  algo: document.getElementById("algo"),
  digits: document.getElementById("digits"),
  period: document.getElementById("period"),
  code: document.getElementById("code"),
  remaining: document.getElementById("remaining"),
  counter: document.getElementById("counter"),
  copyBtn: document.getElementById("copyBtn"),
  oneBackBtn: document.getElementById("oneBackBtn"),
  oneAheadBtn: document.getElementById("oneAheadBtn"),
};

let lastParams = null;
let lastCounter = null;

function readParams() {
  return {
    secretB32: el.secret.value.trim(),
    algo: el.algo.value,
    digits: parseInt(el.digits.value, 10),
    period: Math.max(1, parseInt(el.period.value, 10) || 30),
  };
}

// Atualiza a cada segundo, reaproveitando o mesmo contador quando possível
async function tick(counterShift = 0) {
  try {
    const p = readParams();
    lastParams = p;
    const nowCounter = Math.floor(Math.floor(Date.now() / 1000) / p.period) + counterShift;
    const res = await totp({ ...p, counterOverride: nowCounter });
    lastCounter = res.counter;
    el.code.textContent = res.code.replace(/(\d{3})(?=\d)/g, "$1 ");
    el.remaining.textContent = res.remaining;
    el.counter.textContent = res.counter;
  } catch (e) {
    el.code.textContent = "erro";
    el.remaining.textContent = "--";
    console.error(e);
  }
}

let shift = 0;
setInterval(() => tick(shift), 1000);

["input", "change"].forEach(evt => {
  el.secret.addEventListener(evt, () => { shift = 0; tick(0); });
  el.algo.addEventListener(evt, () => { shift = 0; tick(0); });
  el.digits.addEventListener(evt, () => { shift = 0; tick(0); });
  el.period.addEventListener(evt, () => { shift = 0; tick(0); });
});

el.copyBtn.addEventListener("click", async () => {
  const txt = el.code.textContent.replace(/\s+/g, "");
  try {
    await navigator.clipboard.writeText(txt);
    el.copyBtn.textContent = "Copiado!";
    setTimeout(() => (el.copyBtn.textContent = "Copiar código"), 1000);
  } catch {
    alert("Falha ao copiar.");
  }
});

el.oneBackBtn.addEventListener("click", () => { shift = -1; tick(shift); });
el.oneAheadBtn.addEventListener("click", () => { shift = +1; tick(shift); });

/* ===== Extras: carregar por otpauth:// na URL (opcional) =====
   Ex.: totp.html#otpauth://totp/Conta?secret=JBSW...&issuer=Ex&algorithm=SHA1&digits=6&period=30
*/
(function tryLoadOtpauthFromHash() {
  try {
    const hash = decodeURIComponent(location.hash || "");
    if (!hash.startsWith("#otpauth://")) return;
    const url = new URL(hash.slice(1));
    const secret = url.searchParams.get("secret") || "";
    const algo = (url.searchParams.get("algorithm") || "SHA1").toUpperCase().replace("SHA", "SHA-");
    const digits = parseInt(url.searchParams.get("digits") || "6", 10);
    const period = parseInt(url.searchParams.get("period") || "30", 10);
    if (secret) el.secret.value = secret;
    if (["SHA-1","SHA-256","SHA-512"].includes(algo)) el.algo.value = algo;
    if ([6,7,8].includes(digits)) el.digits.value = String(digits);
    if (period > 0) el.period.value = String(period);
  } catch {}
})();
</script>
</body>
</html>
